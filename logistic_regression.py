# -*- coding: utf-8 -*-
"""Logistic_Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bxyB1F65aVVz6JjIUO6wCtQftEsCdXO2

# Task
Build a logistic regression model for a classification problem, including data loading, exploration, preprocessing, model training, performance evaluation, interpretation of coefficients, and deployment as a Streamlit application. Finally, provide a summary of the analysis.

## Load and Explore Data

### Subtask:
Load the dataset into a pandas DataFrame. Perform exploratory data analysis (EDA) by examining feature types, summary statistics, and identifying any initial patterns or correlations. Create visualizations such as histograms, box plots, or pair plots to understand distributions and relationships between features.

**Reasoning**:
Load the dataset 'diabetes.csv' into a pandas DataFrame and display the first 5 rows to inspect its structure as per the first instruction.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
df = pd.read_csv('diabetes.csv')

# Display the first 5 rows
print("First 5 rows of the DataFrame:")
print(df.head())

print("\nDataFrame Info:")
df.info()

print("\nDescriptive Statistics:")
print(df.describe())

print("\nMissing Values:")
print(df.isnull().sum())

print("\nDuplicate Rows:")
print(df.duplicated().sum())

numerical_cols = df.select_dtypes(include=['int64', 'float64']).columns

import streamlit as st

# Page title
st.title("Data Visualization Dashboard")

# Show data
st.subheader("Dataset Preview")
st.dataframe(df.head())

# ------------------------------
# Histogram
# ------------------------------
st.subheader("Histogram")
fig1, ax1 = plt.subplots(figsize=(8,5))
df.hist(ax=ax1)
st.pyplot(fig1)

# ------------------------------
# Box Plot
# ------------------------------
st.subheader("Box Plot")
fig2, ax2 = plt.subplots(figsize=(10,4))
sns.boxplot(data=df, ax=ax2)
st.pyplot(fig2)

# ------------------------------
# Correlation Heatmap
# ------------------------------
st.subheader("Correlation Heatmap")
fig3, ax3 = plt.subplots(figsize=(8,6))
sns.heatmap(df.corr(), annot=True, cmap="coolwarm", ax=ax3)
st.pyplot(fig3)


plt.figure(figsize=(20, 15))
for i, col in enumerate(numerical_cols):
    plt.subplot(3, 3, i + 1) # Adjust subplot grid as needed
    sns.histplot(df[col], kde=True)
    plt.title(f'Distribution of {col}')
    plt.xlabel(col)
    plt.ylabel('Frequency')
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 8))
sns.heatmap(df[numerical_cols].corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Heatmap of Numerical Features')
plt.show()

cols_with_zero = ['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']

for col in cols_with_zero:
    median_val = df[col].median()
    df[col] = df[col].replace(0, median_val)

print("After replacing 0s with median:")
print(df[cols_with_zero].head())

from sklearn.preprocessing import StandardScaler

# Separate features (X) and target (y)
X = df.drop('Outcome', axis=1)
y = df['Outcome']

# Initialize StandardScaler
scaler = StandardScaler()

# Fit and transform the features
X = scaler.fit_transform(X)

print("Shape of X after scaling:", X.shape)
print("Shape of y:", y.shape)
print("First 5 rows of scaled X:\n", X[:5])

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)

print(f"X_train shape: {X_train.shape}")
print(f"X_test shape: {X_test.shape}")
print(f"y_train shape: {y_train.shape}")
print(f"y_test shape: {y_test.shape}")

# Initialize the Logistic Regression model
model = LogisticRegression(max_iter=200, random_state=42)

# Train the model
model.fit(X_train, y_train)

print("Logistic Regression model trained successfully.")

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, roc_curve

# Make predictions on the test data
y_pred = model.predict(X_test)
y_prob = model.predict_proba(X_test)[:, 1] # Probability of the positive class

# Calculate evaluation metrics
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

print(f"Accuracy: {accuracy:.4f}")
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1-Score: {f1:.4f}")

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate ROC-AUC score
roc_auc = roc_auc_score(y_test, y_prob)
print(f"ROC-AUC Score: {roc_auc:.4f}")

# Compute FPR, TPR, and thresholds for the ROC curve
fpr, tpr, thresholds = roc_curve(y_test, y_prob)

# Plot the ROC curve
plt.figure(figsize=(8, 6))
sns.lineplot(x=fpr, y=tpr, label=f'ROC Curve (AUC = {roc_auc:.2f})')
sns.lineplot(x=[0, 1], y=[0, 1], linestyle='--', color='gray', label='Random Classifier')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend()
plt.grid(True)
plt.show()

import pandas as pd

# 1. Extract the coefficients
coefficients = model.coef_[0]

# 2. Get the names of the features
feature_names = df.drop('Outcome', axis=1).columns

# 3. Create a pandas DataFrame to display coefficients
coef_df = pd.DataFrame({
    'Feature': feature_names,
    'Coefficient': coefficients
})

# 4. Sort the DataFrame by the absolute value of coefficients
coef_df['Absolute_Coefficient'] = abs(coef_df['Coefficient'])
coef_df = coef_df.sort_values(by='Absolute_Coefficient', ascending=False).drop('Absolute_Coefficient', axis=1)

# 5. Print the coef_df
print("Model Coefficients and their influence:")
print(coef_df)

import joblib


joblib.dump(model, 'logistic_regression_model.pkl')
print("Logistic Regression model saved as 'logistic_regression_model.pkl'")


joblib.dump(scaler, 'scaler.pkl')
print("StandardScaler saved as 'scaler.pkl'")

import streamlit as st
import joblib
import pandas as pd
import numpy as np

# Load the trained model and scaler
model = joblib.load('logistic_regression_model.pkl')
scaler = joblib.load('scaler.pkl')

# Define the feature names in the correct order
feature_names = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']

# Streamlit App Title
st.title('Diabetes Prediction App')
st.write('Enter the patient\'s details below to predict the likelihood of diabetes.')

# Input fields for features
pregnancies = st.number_input('Pregnancies (Number of times pregnant)', min_value=0, max_value=17, value=1)
glucose = st.number_input('Glucose (Plasma glucose concentration a 2 hours in an oral glucose tolerance test)', min_value=0, max_value=200, value=120)
blood_pressure = st.number_input('Blood Pressure (Diastolic blood pressure (mm Hg))', min_value=0, max_value=122, value=70)
skin_thickness = st.number_input('Skin Thickness (Triceps skin fold thickness (mm))', min_value=0, max_value=99, value=20)
insulin = st.number_input('Insulin (2-Hour serum insulin (mu U/ml))', min_value=0, max_value=846, value=79)
bmi = st.number_input('BMI (Body mass index (weight in kg/(height in m)^2))', min_value=0.0, max_value=67.1, value=30.0, format="%.1f")
dpf = st.number_input('Diabetes Pedigree Function', min_value=0.0, max_value=2.5, value=0.4, format="%.3f")
age = st.number_input('Age (years)', min_value=1, max_value=120, value=30)

# Prediction button
if st.button('Predict Diabetes'):
    # Create a DataFrame from user inputs
    input_data = pd.DataFrame([[pregnancies, glucose, blood_pressure, skin_thickness, insulin, bmi, dpf, age]],
                              columns=feature_names)

    # Scale the input data
    scaled_input_data = scaler.transform(input_data)

    # Make prediction
    prediction = model.predict(scaled_input_data)
    prediction_proba = model.predict_proba(scaled_input_data)[0]

    st.subheader('Prediction Result:')
    if prediction[0] == 1:
        st.error(f'The model predicts: **DIABETIC**')
        st.write(f'Probability of Diabetes: **{prediction_proba[1]:.2f}**')
    else:
        st.success(f'The model predicts: **NON-DIABETIC**')
        st.write(f'Probability of Non-Diabetes: **{prediction_proba[0]:.2f}**')
